---
title: Introduction to TVTB
author:
    -   name: KÃ©vin Rue-Albrecht
        email: k.rue-albrecht@imperial.ac.uk
        affiliation: Department of Medicine, Imperial College London,
            Hammersmith Campus, Du Cane Road, London, W12 0NN, UK
date: "`r doc_date()`"
package: "`r pkg_ver('TVTB')`"
abstract:
    The VCF Tool Box (*TVTB*) provides functions to summarise and
    visualise gene-centric genetic variation data stored in VCF files
    pre-processed by the Ensembl Variant Effect Predictor (VEP).
    A Shiny web-application, the Shiny Variant Explorer (tSVE),
    provides a convenient interface to demonstrate
    those functionalities in a programming-free environment.
vignette: >
    %\VignetteIndexEntry{Introduction to TVTB}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
output: 
    BiocStyle::pdf_document2
bibliography:
    Introduction.bib
---

```{r, optChunkDefault, include=FALSE}
library(knitr)
optChunkDefault <- opts_chunk$get()
```

# Introduction

The VCF Tool Box (`r Biocpkg("TVTB")`) offers functions
to summarise and visualise gene-centric genetic variation data
stored in VCF files pre-processed by the
Ensembl Variant Effect Predictor (VEP) [@RN1].
A Shiny web-application, the Shiny Variant Explorer (tSVE),
provides a convenient interface to demonstrate those
functionalities in a programming-free environment.

# Installation

The VCF Tool Box can be installed using the following code:

```{r biocLite, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("TVTB")
```

Once installed, the package can be loaded and attached as follows:

```{r library, message=FALSE}
library(TVTB)
```

# Recurrent settings: TVTBparam

Many functionalities in `r Biocpkg("TVTB")` require recurrent information
such as:

* genotypes (homozygote reference, heterozygote, homozygote alternate)
* INFO key field that contains the Ensembl VEP predictions in the VCF file
* suffixes of INFO keys where counts and frequencies of genotypes are stored
    + counts and frequencies may be calculated for levels of phenotypes,
        in which case the corresponding INFO keys are formed as
        `<phenotype>_<level>_<suffix>`
    + counts and frequencies across all samples are stored in INFO keys
        simply named `<suffix>`
* settings for parallel calculations

To reduce the burden of repetitive programming, and to 
facilitate analyses using consistent sets of parameters,
`r Biocpkg("TVTB")` implements the `TVTBparam` class.
`TVTBparam` objects offer a container for parameters recurrently used across
the package.
A `TVTBparam` object may be initialised as follows:

```{r TVTBparamCreate}
tparam <- TVTBparam(
    genos = list(
        REF = c("0|0"),
        HET = c("0|1", "1|0"),
        ALT = c("1|1")),
    ranges = GenomicRanges::GRanges(
        seqnames = "15",
        IRanges::IRanges(
            start = 48413170, end = 48434757, names = "SLC24A5")),
    aaf = "AAF", # default
    maf = "MAF", # default
    vep = "CSQ", # default
    bp = BiocParallel::SerialParam()) # default
```
\fixme{
In the future, add a second region to the `ranges` slot, to demonstrate
relevant features (e.g. plots faceted by range).
}

`TVTBparam` objects have a convenient summary view:

```{r TVTBparamView}
tparam
```

In this example:

* **Genotypes**
    + homozygote reference genotype is encoded `0|0`
        - counts of genotypes are stored in INFO keys suffixed with `REF`
    + heterozygote genotypes are encoded either `0|1` or `1|0`
        - counts of genotypes are stored in INFO keys suffixed with `HET`
    + homozygote alternate  genotype is encoded `1|1`
        - counts of genotypes are stored in INFO keys suffixed with `ALT`
* **Genomic ranges**
    + a gene-coding region on chromosome 15
* **Alternate allele frequency**
    + stored in INFO keys suffixed with `AAF`
* **Minor allele frequency**
    + stored in INFO keys suffixed with `MAF`
* **Ensembl VEP predictions**
    + imported from INFO key `CSQ`
* **Parallel calculations**
    + turned off. Serial calculations are performed.

Default values are provided for all slots except genotypes, as these may vary
more frequently from one data set to another.
\bioccomment{
In the future, however, a small set of pre-configured `TVTBparam` objects
may be included in the package for the most common situations
(e.g., `TVTBparamPhased`, `TVTBparamUnphased`, `TVTBparam012`).
}

# Data import

## Genetic variants

Functionalities in `r Biocpkg("TVTB")` currently only support
`ExpandedVCF` objects of the `r Biocpkg("VariantAnnotation")` package,
that encode a single alternate allele per record.
`ExpandedVCF` objects may be produced
from `r Biocpkg("VariantAnnotation")` `CollapsedVCF` objects
using the `r Biocpkg("VariantAnnotation")` `expand()` method.

`ExpandedVCF` objects may include any information that users deem relevant
for the analysis;
however, to enable the key functionalities of the `r Biocpkg("TVTB")` package,
the object should include at least the following information:

* `fixed(x)`
    + `ALT`: alternate allele(s)
    
* `info(x)`
    + `<vep>`: where `<vep>` stands for a user-defined INFO key where
    the Ensembl VEP predictions are stored in the `ExpandedVCF` object
    
* `geno(x)`
    + `GT`: genotypes

* `colData(x)`: phenotypes

## Genomic ranges

To reduce memory requirements and the duration of the calculations steps,
users may wish to import only a subset of variants from specific genomic
region(s) (*e.g.* gene-coding, exons, promoters).

The `r Biocpkg("VariantAnnotation")` `ScanVcfParam` class accepts
`r Biocpkg("GenomicRanges")` `GRanges` objects
(in the `which` slot) that describes
the sequences and ranges to be queried from the VCF file.

## Phenotypes

Phenotype information is essential to interpret and compare genetic variants
between groups of samples
(*e.g.* minor allele frequency in a group, burden of damaging variants).

`ExpandedVCF` objects accepts phenotype information
(as `r Biocpkg("S4Vectors")` `DataFrame`) in the `colData` slot.
This has several advantages, among which:

* Phenotype and genetic information are kept synchronised through operation
    such as subsetting and re-ordering
* `ExpandedVCF` objects ensure that the `rownames` of their `colData` slot
    matches the `colnames` or their `geno` and `info` slots.
    
The `r Biocpkg("VariantAnnotation")` `ScanVcfParam` class accepts
sample names (given as a `character` vector) in the `samples` slot
that describes the samples to be queried from the VCF file.

## Example

An `ExpandedVCF` object that contains the minimal data necessary for the rest
of the vignette can be created as follows:

**Step 1:** Import phenotypes

```{r importPhenotypes}
extdata <- system.file("extdata", package = "TVTB")
phenoFile <- file.path(extdata, "integrated_samples.txt")
phenotypes <- S4Vectors::DataFrame(
    read.table(file = phenoFile, header = TRUE, row.names = 1))
```

**Step 2:** Define VCF file

```{r vcfFile}
vcfFile <- file.path(extdata, "chr15.phase3_integrated.vcf.gz")
tabixVcf <- Rsamtools::TabixFile(file = vcfFile)
```

**Step 3:** Define VCF import parameters

Of particular interest:

* `samples`: import only samples with phenotype information
* `which`: import only variants in the targeted genomic range

```{r ScanVcfParam}
svp <- VariantAnnotation::ScanVcfParam(
    fixed = c("ALT", "QUAL", "FILTER"), # all fields: could be omitted
    info = c(vep(tparam)),
    geno = "GT", # all fields: could be omitted
    samples = rownames(phenotypes),
    which = ranges(tparam))
```

**Step 4:** Import and pre-process variants

```{r preprocessVariants, message=FALSE}
library(SummarizedExperiment)
# Import variants as a CollapsedVCF object
vcf <- VariantAnnotation::readVcf(file = vcfFile, param = svp)
# Combine with phenotype information
colData(vcf) <- phenotypes
# Expand into a ExpandedVCF object (bi-allelic records)
vcf <- VariantAnnotation::expand(x = vcf, row.names = TRUE)
# Disambiguate rownames of multi-allelic variants
rownames(vcf) <- paste(rownames(vcf), mcols(vcf)[,"ALT"], sep = "_")
```

\fixme{
Currently, the package relies on the ExpandedVCF object to have
unique row names. A fix will be implemented soon.
}

The result is an `ExpandedVCF` object including variants
in the desired genomic ranges and samples:

```{r vcf, echo=FALSE}
vcf
```

# Summarising Ensembl VEP predictions

Although later sections discuss:

* the calculation of additional `info` fields (\fixme{Coming soon!}) 
* the filtering of variants based on `fixed`, `info`, and `geno` fields
    (\fixme{Coming soon!})

, interesting figures and summary tables may be obtained as soon as the first
`ExpandedVCF` object is created.

Currently, major `r Biocpkg("TVTB")` functionalities include:

* Counting discrete Ensembl VEP predictions in levels of a phenotype
    + as a `data.frame` or a stacked `r Biocpkg("ggplot2") `geom_bar`
    + counts faceted by another Ensembl VEP prediction (*e.g.* `"Feature"`")
    + `geom_bar` represented as stacked *percentage* of predictions
* Density distribution of continuous Ensembl VEP predictions in levels of
    a phenotype
    + density faceted by another Ensembl VEP prediction
* Adding genotype counts and allele frequencies to the `ExpandedVCF` object
    + counts and frequencies within level(s) of phenotype(s)
    + overall counts and frequencies (*i.e.* across all samples)
* Subset `ExpandedVCF` objects using a combination of filters on data in
    the `fixed` data, `info` data, and Ensembl VEP preditions

## Counts of discrete Ensembl VEP predictions

### Barplot

The following chunk of code displays,
for each genomic feature affected,
the count of each Ensembl VEP prediction
`"Consequence"` in each "super population"
(*i.e.*, each level of the `"super_pop"` phenotype).

```{r optsTabulateSet, include=FALSE}
opts_chunk$set(
    fig.width=13, fig.height=7,
    out.extra='angle=90',
    out.width='7in', out.height='13in'
)
```

```{r tCBPplot, message=FALSE}
library(ggplot2)
tCBPplot <- tabulateCsqByPhenotype(
    vcf = vcf, phenoCol = "super_pop", csqCol = "Consequence",
    param = tparam,
    unique = TRUE, facet = "Feature", percentage = FALSE,
    plot = TRUE) +
    theme(
        legend.text = element_text(size = rel(0.8)),
        axis.text.x = element_text(angle = 270,vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270,hjust = 0.5)
    )

tCBPplot
```

```{r optsTabulateReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

### Table (data.frame)

The same counts can also be summarised as a `data.frame` using
the option `plot=FALSE`:

```{r tCBPtableWide}
tCBPwide <- tabulateCsqByPhenotype(
        vcf = vcf, phenoCol = "super_pop", csqCol = "Consequence",
        param = tparam,
        unique = TRUE, facet = "Feature", plot = FALSE
    )
```

of which only the subset corresponding to *missense variants* is shown here:

```{r tCBPtableWideSubset, eval=FALSE}
subset(tCBPwide, Consequence == "missense_variant")
```

```{r tCBPtableWideSubsetShow, results="asis", echo=FALSE}
knitr::kable(
    x = subset(tCBPwide, Consequence == "missense_variant"),
    row.names = FALSE,
    caption = "Table of consequence by phenotype by feature in wide format")
```

## Distribution of continuous Ensembl VEP predictions

For Ensembl VEP prediction on a continuous scale, it may be interesting to
visualise the distribution of values as a density plot.
In the following chunk of code, the density distribution of
[CADD score](http://cadd.gs.washington.edu)
(a tool for scoring the deleteriousness of genetic variants)
is visualised for variant affecting each feature in each super-population:

```{r optsDensitySet, include=FALSE}
opts_chunk$set(
    fig.width=13, fig.height=7,
    out.extra='angle=90',
    out.width='7in', out.height='13in'
)
```

```{r dCBPplot, warning=FALSE}
densityCsqByPhenotype(
        vcf = vcf, phenoCol = "super_pop", csqCol = "CADD_PHRED",
        param = tparam,
        unique = TRUE, facet = "Feature", plot = TRUE, popFreq = FALSE) +
    theme(
        legend.key.size = unit(1.2, "lines"),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)),
        axis.text.x = element_text(angle = 270,
            vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270, hjust = 0.5)
    )
```

```{r optsDensityReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

# Session info

Here is the output of `sessionInfo()` on the system on which this document was
compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References

[R]: http://r-project.org
[RStudio]: http://www.rstudio.com/
