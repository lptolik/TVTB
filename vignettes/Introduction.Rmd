---
title: Introduction to TVTB
author:
    -   name: KÃ©vin Rue-Albrecht
        email: k.rue-albrecht@imperial.ac.uk
        affiliation: Department of Medicine, Imperial College London,
            Hammersmith Campus, Du Cane Road, London, W12 0NN, UK
date: "`r doc_date()`"
package: "`r pkg_ver('TVTB')`"
abstract:
    The VCF Tool Box (*TVTB*) provides functions to summarise and
    visualise genetic variation data stored in VCF files
    pre-processed by the Ensembl Variant Effect Predictor (VEP).
    A Shiny web-application, the Shiny Variant Explorer (*tSVE*),
    provides a convenient interface to demonstrate
    those functionalities in a programming-free environment.
vignette: >
    %\VignetteIndexEntry{Introduction to TVTB}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
output:
    BiocStyle::pdf_document2:
        toc_newpage: true
bibliography:
    TVTB.bib
---

```{r, optChunkDefault, include=FALSE}
library(knitr)
optChunkDefault <- opts_chunk$get()
```

# Introduction {#Introduction}

The VCF Tool Box (`r Biocpkg("TVTB")`) offers functions
to summarise and visualise genetic variation data
stored in VCF files pre-processed by the
Ensembl Variant Effect Predictor (VEP) [@RN1].
An [RStudio/Shiny](http://shiny.rstudio.com) web-application,
the Shiny Variant Explorer (*tSVE*),
provides a convenient interface to demonstrate those
functionalities in a programming-free environment.

Currently, major functionalities in the `r Biocpkg("TVTB")` package include:

**Container for analysis parameters**

* List of reference homozygote, heterozygote, and alternate homozygote
    genotype encodings
* Suffix of INFO fields where calculated data should be stored
* Key of the INFO field where Ensembl VEP predictions are stored
* Genomic ranges to analyse
* Parameters for parallel calculations

**Genotype counts and allele frequencies**

* Calculated from the data of an `ExpandedVCF` objects
* Stored in INFO fields of the `ExpandedVCF` object
    + overall counts and frequencies (*i.e.* across all samples)
    + counts and frequencies within level(s) of phenotype(s)

**VCF filter rules**

* Filter rules applicable to the `fixed` slot of an `VCF` object
* Filter rules applicable to the `info` slot of an `VCF` object
* Filter rules applicable to the Ensembl VEP predictions stored in a given slot
of an `VCF` object
* Subset a `VCF` object using any combination of the above filter rules

**Counts of discrete Ensembl VEP predictions**

* Count VEP predictions in levels of a given phenotype
    + represented as a `data.frame` or a stacked `r Biocpkg("ggplot2")`
    `geom_bar` layer
    + optionally faceted by another Ensembl VEP prediction (*e.g.* `"Feature"`)
    + `geom_bar` layer representing stacked *percentage* of predictions

**Density of continuous Ensembl VEP predictions**

* in levels of a phenotype
    + as a `r Biocpkg("ggplot2")` `geom_density` and/or `geom_dotplot` layer
    + optionally faceted by another Ensembl VEP prediction

# Installation {#Installation}

The VCF Tool Box can be installed using the following code:

```{r biocLite, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("TVTB")
```

Once installed, the package can be loaded and attached as follows:

```{r library, message=FALSE}
library(TVTB)
```

# Recurrent settings: TVTBparam {#TVTBparam}

Many functionalities in `r Biocpkg("TVTB")` require recurrent information
such as:

* genotypes (homozygote reference, heterozygote, homozygote alternate)
* INFO key that contains the Ensembl VEP predictions in the VCF file
* suffixes of INFO keys where counts and frequencies of genotypes are stored
    + counts and frequencies may be calculated for levels of phenotypes,
        in which case the corresponding INFO keys are formed as
        `<phenotype>_<level>_<suffix>`
    + counts and frequencies across all samples are stored in INFO keys
        simply named `<suffix>`
* settings for parallel calculations

To reduce the burden of repetition, and to 
facilitate analyses using consistent sets of parameters,
`r Biocpkg("TVTB")` implements the `TVTBparam` class.
`TVTBparam` objects offer a container for parameters recurrently used across
the package.
A `TVTBparam` object may be initialised as follows:

```{r TVTBparamCreate}
tparam <- TVTBparam(
    genos = list(
        REF = c("0|0"),
        HET = c("0|1", "1|0", "1|2", "2|1"),
        ALT = c("1|1", "2|2")),
    ranges = GenomicRanges::GRanges(
        seqnames = "15",
        IRanges::IRanges(
            start = 48413170, end = 48434757, names = "SLC24A5")),
    aaf = "AAF", # default
    maf = "MAF", # default
    vep = "CSQ", # default
    bp = BiocParallel::SerialParam()) # default
```
\bioccomment{
In the future, add a second region to the `ranges` slot, to demonstrate
relevant features (e.g. plots faceted by genomic range).
}

`TVTBparam` objects have a convenient summary view:

```{r TVTBparamView}
tparam
```

In this example:

* **Genotypes**
    + homozygote reference genotype is encoded `0|0`
        - counts of genotypes are stored in INFO keys suffixed with `REF`
    + heterozygote genotypes are encoded either `0|1` or `1|0`
        - counts of genotypes are stored in INFO keys suffixed with `HET`
    + homozygote alternate  genotype is encoded `1|1`
        - counts of genotypes are stored in INFO keys suffixed with `ALT`
* **Genomic ranges**
    + a gene-coding region on chromosome 15
* **Alternate allele frequency**
    + stored in INFO keys suffixed with `AAF`
* **Minor allele frequency**
    + stored in INFO keys suffixed with `MAF`
* **Ensembl VEP predictions**
    + imported from INFO key `CSQ`
* **Parallel calculations**
    + turned off. Serial calculations are performed.

Default values are provided for all slots except genotypes, as these may vary
more frequently from one data set to another.
\bioccomment{
In the future, however, a small set of pre-configured `TVTBparam` objects
may be included in the package for the most common situations
(e.g., `TVTBparamPhased`, `TVTBparamUnphased`, `TVTBparam012`).
}

# Data import {#Import}

## Genetic variants {#ImportVariants}

Functionalities in `r Biocpkg("TVTB")` currently only support
`ExpandedVCF` objects of the `r Biocpkg("VariantAnnotation")` package,
that encode a single alternate allele per record.
`ExpandedVCF` objects may be produced
from `r Biocpkg("VariantAnnotation")` `CollapsedVCF` objects
using the `r Biocpkg("VariantAnnotation")` `expand()` method.

`ExpandedVCF` objects may include any information that users deem relevant
for the analysis;
however, to enable the key functionalities of the `r Biocpkg("TVTB")` package,
the object should include at least the following information:

* `fixed(x)`
    + No minimal requirement.
    
* `info(x)`
    + `<vep>`: where `<vep>` stands for a user-defined INFO key where
    the Ensembl VEP predictions are stored in the `ExpandedVCF` object
    
* `geno(x)`
    + `GT`: genotypes

* `colData(x)`: phenotypes

## Genomic ranges {#ImportGRanges}

To reduce memory requirements and the duration of the calculations steps,
users may wish to import only a subset of variants from specific genomic
region(s) (*e.g.* gene-coding, exons, promoters).

\bioccomment{
In the future, genomic ranges may be used to produce summary statistics
and plots faceted by range (e.g. burden).
}

Notably, the `r Biocpkg("VariantAnnotation")` `ScanVcfParam` class accepts
`r Biocpkg("GenomicRanges")` `GRanges` objects
(in the `which` slot) that describes
the sequences and ranges to be queried from the VCF file.

## Phenotypes {#ImportPhenotypes}

Although `ExpandedVCF` objects may exist without it,
phenotype information is essential to interpret and compare genetic variants
between groups of samples
(*e.g.* minor allele frequency in a group, burden of damaging variants).

`ExpandedVCF` objects accept phenotype information
(as `r Biocpkg("S4Vectors")` `DataFrame`) in the `colData` slot.
This practice has the key advantage of keeping phenotype and genetic
information synchronised through operation such as subsetting and re-ordering,
limiting [software entropy](https://en.wikipedia.org/wiki/Software_entropy).
    
Notably, the `r Biocpkg("VariantAnnotation")` `ScanVcfParam` class accepts
sample names (given as a `character` vector) in the `samples` slot
that describes the samples to be queried from the VCF file.

## Example {#ImportExample}

An `ExpandedVCF` object that contains the minimal data necessary for the rest
of the vignette can be created as follows:

**Step 1:** Import phenotypes

```{r importPhenotypes}
extdata <- system.file("extdata", package = "TVTB")
phenoFile <- file.path(extdata, "integrated_samples.txt")
phenotypes <- S4Vectors::DataFrame(
    read.table(file = phenoFile, header = TRUE, row.names = 1))
```

**Step 2:** Define VCF file

```{r vcfFile}
vcfFile <- file.path(extdata, "chr15.phase3_integrated.vcf.gz")
tabixVcf <- Rsamtools::TabixFile(file = vcfFile)
```

**Step 3:** Define VCF import parameters

Of particular interest:

* `samples`: import only samples with phenotype information
* `which`: import only variants in the targeted genomic range

```{r ScanVcfParam}
svp <- VariantAnnotation::ScanVcfParam(
    fixed = c("ALT", "QUAL", "FILTER"), # all fields: could be omitted
    info = vep(tparam), # an application of the TVTBparam class
    geno = "GT", # all fields: could be omitted in this case
    samples = rownames(phenotypes),
    which = ranges(tparam))
```

**Step 4:** Import and pre-process variants

```{r preprocessVariants, message=FALSE}
# Import variants as a CollapsedVCF object
vcf <- VariantAnnotation::readVcf(file = tabixVcf, param = svp)
# Combine with phenotype information
SummarizedExperiment::colData(vcf) <- phenotypes
# Expand into a ExpandedVCF object (bi-allelic records)
vcf <- VariantAnnotation::expand(x = vcf, row.names = TRUE)
```

The result is an `ExpandedVCF` object including variants
in the desired genomic range(s) and samples:

```{r vcf, echo=FALSE}
vcf
```

# Adding allele frequencies {#Frequencies}

Although interesting figures and summary tables may be obtained
as soon as the first `ExpandedVCF` object is created
(see section [Summarising Ensembl VEP predictions](#Summarise)),
those methods may benefit from information added to additional INFO keys
after data import, either manually by the user, or through various
methods implemented in the `r Biocpkg("TVTB")` package.

## Adding overall frequencies {#FrequenciesOverall}

For instance, the method `addOverallFrequencies` uses the
reference homozoygote (*REF*), heterozygote (*HET*),
and homozygote alternate (*ALT*) genotypes defined in a `TVTBparam` object
to obtain the count of each genotype in an `ExpandedVCF` object.
Immediately thereafter, the method uses those counts to calculate
alternate allele frequency (*AAF*) and minor allele frequency (*MAF*).
Finally, the method stores the five calculated values
(*REF*, *HET*, *ALT*, *AAF*, and *MAF*)
in INFO keys defined by suffixes also declared in the `TVTBparam` object.

```{r addOverallFrequencies}
initialInfo <- colnames(info(vcf))
vcf <- addOverallFrequencies(vcf = vcf, param = tparam)
setdiff(colnames(info(vcf)), initialInfo)
```

Notably, the `addOverallFrequencies` method is synonym to the `addFrequencies`
method missing the argument `phenos`:

```{r addFrequenciesOverall}
vcf <- addFrequencies(vcf = vcf, param = tparam, force = TRUE)
```

\bioccomment{
The optional argument `force = TRUE` is used here
to overwrite existing INFO keys
present in both the `header` or the `info` slots of the `ExpandedVCF` object.
}

## Adding frequencies in phenotype level(s) {#FrequenciesPhenoLevel}

Similarly, the method `addPhenoLevelFrequencies` obtains the count of each
genotype in samples associated with a given level of a given phenotype,
and stores the calculated values in INFO keys defined as 
`<pheno>_<level>_<suffix>`, with suffixes defined in the `TVTBparam` object.

```{r addPhenoLevelFrequencies}
initialInfo <- colnames(info(vcf))
vcf <- addPhenoLevelFrequencies(
    vcf = vcf, pheno = "super_pop", level = "AFR", param = tparam)
setdiff(colnames(info(vcf)), initialInfo)
```

Notably, the `addOverallFrequencies` method is synonym to the `addFrequencies`
method called with the argument `phenos` given as a list where `names` are
phenotypes, and values are `character` vectors of levels to
process within each phenotype:

```{r addFrequenciesPhenoLevel}
initialInfo <- colnames(info(vcf))
vcf <- addFrequencies(
    vcf = vcf, phenos = list(
        super_pop = c("EUR", "AFR"),
        pop = c("GBR", "FIN", "MSL")),
    param = tparam, force = TRUE)
setdiff(colnames(info(vcf)), initialInfo)
```

# Filtering variants {#Filter}

Although `VCF` objects are straightforward to subset
using either indices and row names
(as they inherit from the `r Biocpkg("SummarizedExperiment")` 
`RangedSummarizedExperiment` class),
users may wish to identify variants that pass combinations of criteria based on
information in their `fixed` slot, `info` slot, and Ensembl VEP predictions,
a non-trivial task due to those pieces of information being stored in
different slots of the `VCF` object, and the *1:N* relationship
between variants and EnsemblVEP predictions.

## Definition of VCF filter rules {#FilterDefine}

To facilitate the definition of VCF filter rules, and their application to
`ExpandedVCF` objects, `r Biocpkg("TVTB")` extends the `r Biocpkg("S4Vectors")`
`FilterRules` class in four new classes of filter rules:

|       Class       | Motivation                                              |
| :--------------:  | :------------------------------------------------------ |
|  VcfFixedRules    | Filter rules applicable to the `fixed` slot of an       |
|                   | `ExpandedVCF` object.                                   |
|                   |                                                         |
|   VcfInfoRules    | Filter rules applicable to the `info` slot of an        |
|                   | `ExpandedVCF` object.                                   |
|                   |                                                         |
|   VcfVepRules     | Filter rules applicable to the Ensembl VEP predictions  |
|                   | stored in a given INFO key of an `ExpandedVCF` object.  |
|                   |                                                         |
|  VcfFilterRules   | Combination of `VcfFixedRules`, `VcfInfoRules`, and     |
|                   |  `VcfVepRules` applicable to an `ExpandedVCF` object.   |

Table: Motivation for each of the new classes extending `FilterRules`
to define VCF filter rules.

Instances of those classes may be initialised as follows:

**VcfFixedRules**

```{r VcfFixedRules}
fixedR <- VcfFixedRules(exprs = list(
    pass = expression(FILTER == "PASS"),
    qual = expression(QUAL > 20)
    ))
fixedR
```

**VcfInfoRules**

`FilterRules` are initialised in an active state by default.
The `active` argument of their constructor may be used to initialise
certain filter rules in an inactive state.

```{r VcfInfoRules}
infoR <- VcfInfoRules(exprs = list(
    common = expression(MAF > 0.1), # minor allele frequency
    present = expression(ALT + HET > 0) # count of non-REF homozygotes
    ),
    active = c(TRUE, FALSE))
infoR
```

**VcfVepRules**

```{r VcfVepRules}
vepR <- VcfVepRules(exprs = list(
    missense = expression(Consequence %in% c("missense_variant")),
    CADD = expression(CADD_PHRED > 15)
    ))
vepR
```

**VcfFilterRules**

`VcfFilterRules` combine VCF filter rules of  different classes in a single
object.

```{r VcfFilterRules}
vcfRules <- VcfFilterRules(fixedR, infoR, vepR)
vcfRules
```

## Control of VCF filter rules {#FilterControl}

As the above VCF filter rules classes inherit from the `r Biocpkg("S4Vectors")`
`FilterRules` class, they also benefit from its accessors and methods.
For instance, VCF filter rules can easily be toggled
between active and inactive states:

```{r deactivateCADD}
active(vcfRules)["CADD"] <- FALSE
active(vcfRules)
```

## Evaluation of VCF filter rules {#FilterEval}

Once defined, the above filter rules can be applied to `ExpandedVCF` objects,
in the same way as `FilterRules` are evaluated in a given environment:

```{r}
summary(eval(expr = infoR, envir = vcf))
summary(eval(expr = vcfRules, envir = vcf))
summary(evalSeparately(expr = vcfRules, envir = vcf))
```

\bioccomment{
Note how the inactive `VcfVepRules` named `CADD` returns `TRUE`
for all variants.
}

\fixme{
Not sure why in the vignette `summary` behaves like `summary.data.frame`,
while in RStudio it processes the `FilterMatrix` differently (rightly so).
}

# Summarising Ensembl VEP predictions {#Summarise}

As soon as genetic and phenotypic information are imported
into an `ExpandedVCF` object,
or after the object was extended with additional information,
the scientific value of the data may be revealed by
a variety of summary statistics and graphical representations.
This section presents severeal ideas implemented in `r Biocpkg("TVTB")`.

\bioccomment{
Note that `ggplot` objects include the data used for plotting.
Those data may be extracted, replaced, subsetted to produce plots and
summary tables beyond those implemented in the package.
In particular, the associated web-application *tSVE* takes advantage of this
point to avoid calling multiple times the same *TVTB* methods.
}

## Counts of discrete Ensembl VEP predictions {#SummariseDiscrete}

### Barplot {#SummariseDiscreteBarplot}

The following chunk of code displays,
for each genomic feature affected,
the count of each Ensembl VEP prediction `"Consequence"`
summed over variants observed at least once
in each "super population"
(*i.e.*, each level of the `"super_pop"` phenotype).

```{r optsTabulateSet, include=FALSE}
opts_chunk$set(
    fig.width=13, fig.height=7,
    out.extra='angle=90',
    out.width='7in', out.height='13in'
)
```

```{r tCBPplot, message=FALSE}
library(ggplot2)
filterCADD <- VcfVepRules(exprs = list(
    CADD_20 = expression(as.numeric(CADD_PHRED) > 20)
    ))
tCBPplot <- tabulateVepByPhenotype(
    vcf = vcf, phenoCol = "super_pop", vepCol = "Consequence",
    param = tparam, filter = filterCADD,
    unique = TRUE, facet = "Feature", percentage = FALSE,
    plot = TRUE) +
    theme(
        legend.text = element_text(size = rel(0.8)),
        axis.text.x = element_text(angle = 270,vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270,hjust = 0.5)
    )

tCBPplot
```

```{r optsTabulateReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

### Table (data.frame) {#SummariseDiscreteTable}

The same counts can also be summarised as a `data.frame` using
the option `plot=FALSE`:

```{r tCBPtableWide}
tCBPwide <- tabulateVepByPhenotype(
        vcf = vcf, phenoCol = "super_pop", vepCol = "Consequence",
        param = tparam,
        unique = TRUE, facet = "Feature", plot = FALSE
    )
```

of which only the subset corresponding to *missense variants* is shown here:

```{r tCBPtableWideSubset, eval=FALSE}
subset(tCBPwide, Consequence == "missense_variant")
```

```{r tCBPtableWideSubsetShow, results="asis", echo=FALSE}
knitr::kable(
    x = subset(tCBPwide, Consequence == "missense_variant"),
    row.names = FALSE,
    caption = "Table of consequence by phenotype by feature in wide format.")
```

## Distribution of continuous Ensembl VEP predictions {#SummariseContinuous}

For Ensembl VEP predictions on a continuous scale, it may be interesting to
visualise the distribution of values as a density plot.
In the following chunk of code, the density distribution of
[CADD score](http://cadd.gs.washington.edu)
(a tool for scoring the deleteriousness of genetic variants) is visualised
for missense variants affecting each feature in each super-population:

```{r optsDensitySet, include=FALSE}
opts_chunk$set(
    fig.width=13, fig.height=7,
    out.extra='angle=90',
    out.width='7in', out.height='13in'
)
```

```{r dCBPplot, warning=FALSE, message=FALSE}
densityVepByPhenotype(
        vcf = vcf, phenoCol = "super_pop", vepCol = "CADD_PHRED",
        param = tparam, filter = vcfRules["missense"],
        unique = TRUE, facet = "Feature", plot = TRUE, popFreq = FALSE,
        layer = "density+dotplot") +
    theme(
        legend.key.size = unit(1.2, "lines"),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)),
        axis.text.x = element_text(angle = 270,
            vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270, hjust = 0.5)
    )
```

```{r optsDensityReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

# Session info {#SessionInfo}

Here is the output of `sessionInfo()` on the system on which this document was
compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {#References}

[R]: http://r-project.org
[RStudio]: http://www.rstudio.com/
