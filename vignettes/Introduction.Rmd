---
title: Introduction to TVTB
author:
    -   name: KÃ©vin Rue-Albrecht
        email: k.rue-albrecht@imperial.ac.uk
        affiliation: Department of Medicine, Imperial College London,
            Hammersmith Campus, Du Cane Road, London, W12 0NN, UK
date: "`r doc_date()`"
package: "`r pkg_ver('TVTB')`"
abstract:
    The VCF Tool Box (*TVTB*) provides S4 classes and methods to filter,
    summarise and visualise genetic variation data stored in VCF files
    pre-processed by the Ensembl Variant Effect Predictor (VEP).
    In particular, the package extends the *FilterRules* class (*S4Vectors*
    package) to define news classes of filter rules applicable to the various
    slots of `VCF` objects.
    A Shiny web-application, the Shiny Variant Explorer (*tSVE*),
    provides a convenient interface to demonstrate
    those functionalities integrated in a programming-free environment.
vignette: >
    %\VignetteIndexEntry{Introduction to TVTB}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
output:
    BiocStyle::pdf_document2:
        toc_newpage: true
bibliography:
    TVTB.bib
---

```{r, optChunkDefault, include=FALSE}
library(knitr)
optChunkDefault <- opts_chunk$get()
```

# Introduction {#Introduction}

The VCF Tool Box (`r Biocpkg("TVTB")`) offers S4 classes and methods
to filter, summarise and visualise genetic variation data
stored in VCF files pre-processed by the
[Ensembl Variant Effect Predictor](http://www.ensembl.org/info/docs/tools/vep)
(VEP) [@RN1].
An [RStudio/Shiny](http://shiny.rstudio.com) web-application,
the Shiny Variant Explorer (*tSVE*),
provides a convenient interface to demonstrate those
functionalities integrated in a programming-free environment.

Currently, major functionalities in the `r Biocpkg("TVTB")` package include:

**Container for analysis parameters**

* List of reference homozygote, heterozygote, and alternate homozygote
    genotype encodings
* Suffix of INFO fields where calculated data will be stored
* Key of the INFO field where Ensembl VEP predictions are stored
    in the VCF file
* List of genomic ranges to analyse
* Parameters for parallel calculations (requires `r Biocpkg("BiocParallel")`)

**Genotype counts and allele frequencies**

* Calculated from the data of an `ExpandedVCF` objects
    (*i.e.* bi-allelic records)
* Stored in INFO fields of the `ExpandedVCF` object
    + overall counts and frequencies (*i.e.* across all samples)
    + counts and frequencies within level(s) of phenotype(s)

**VCF filter rules**

* Filter rules applicable to the `fixed` slot of an `VCF` object
* Filter rules applicable to the `info` slot of an `VCF` object
* Filter rules applicable to the Ensembl VEP predictions stored in a
given INFO field of a `VCF` object
* Container for combinations of filter rules listed above
* Subset a `VCF` object using any combination of the above filter rules

**Counts of discrete Ensembl VEP predictions**

* Count VEP predictions in levels of a given phenotype
    + returned as a `data.frame` or a stacked `r Biocpkg("ggplot2")`
        `geom_bar` layer
    + optionally faceted by another Ensembl VEP prediction
        (*e.g.* `"Feature"`)
    + `geom_bar` layer representing stacked *percentage* of VEP predictions

**Density of continuous Ensembl VEP predictions**

* Ditribution of VEP predictions in levels of a phenotype
    + as a `r Biocpkg("ggplot2")` `geom_density` and/or `geom_dotplot` layer
    + as a `data.frame` listing all values faceted by phenotype level
    + optionally faceted by another Ensembl VEP prediction

# Installation {#Installation}

The VCF Tool Box can be installed using the following code:

```{r biocLite, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("TVTB")
```

Once installed, the package can be loaded and attached as follows:

```{r library, message=FALSE}
library(TVTB)
```

# Recurrent settings: TVTBparam {#TVTBparam}

Many functionalities in `r Biocpkg("TVTB")` require recurrent information
such as:

* genotype codes (homozygote reference, heterozygote, homozygote alternate)
* INFO key that contains the Ensembl VEP predictions in the VCF file
* suffixes of INFO keys where counts and frequencies of genotypes are stored
    + counts and frequencies may be calculated for individual levels of
        selected phenotypes, in which case the data will be stored
        under INFO keys formed as `<phenotype>_<level>_<suffix>`
    + counts and frequencies across all samples are stored in INFO keys
        simply named `<suffix>`
* settings for parallel calculations

\bioccomment{
INFO key suffixes should be considered carefully to avoid conflicts
with INFO keys already present in the `VCF` object.
}

To reduce the burden of repetition during programming, and to 
facilitate analyses using consistent sets of parameters,
`r Biocpkg("TVTB")` implements the `TVTBparam` class.
The `TVTBparam` class offer a container for parameters recurrently used
across the package.
A `TVTBparam` object may be initialised as follows:

```{r TVTBparamCreate}
tparam <- TVTBparam(
    genos = list(
        REF = c("0|0"),
        HET = c("0|1", "1|0", "0|2", "2|0", "1|2", "2|1"),
        ALT = c("1|1", "2|2")), # required
    ranges = GenomicRanges::GRangesList(GenomicRanges::GRanges(
        seqnames = "15",
        IRanges::IRanges(
            start = 48413170, end = 48434757, names = "SLC24A5")
        )), # optional
    aaf = "AAF", # default (optional)
    maf = "MAF", # default (optional)
    vep = "CSQ", # default (optional)
    bp = BiocParallel::SerialParam()) # default (optional)
```

`TVTBparam` objects have a convenient summary view:

```{r TVTBparamView}
tparam
```

In this example:

* **Genotypes**
    + homozygote reference genotype is encoded `"0|0"`
    + counts of reference genotypes are stored in INFO keys suffixed with
        `"REF"`
    + heterozygote genotypes are encoded as
        `"0|1"`, `"1|0"`, `"0|2"`, `"2|0"`, `"1|2"`, and `"2|1"`
    + counts of heterozygote genotypes are stored in INFO keys suffixed with
        `"HET"`
    + homozygote alternate  genotype is encoded `"1|1"`
    + counts of alternate genotypes are stored in INFO keys suffixed with
        `"ALT"`
* **Genomic ranges**
    + a gene-coding region on chromosome `"15"`
* **Alternate allele frequency**
    + stored in INFO keys suffixed with `"AAF"`
* **Minor allele frequency**
    + stored in INFO keys suffixed with `"MAF"`
* **Ensembl VEP predictions**
    + imported from INFO key `"CSQ"`
* **Parallel calculations**
    + turned off. Serial calculations are performed.

Default values are provided for all slots except genotypes, as these may vary
more frequently from one data set to another.

# Data import {#Import}

## Genetic variants {#ImportVariants}

Functionalities in `r Biocpkg("TVTB")` support
`CollapsedVCF` and `ExpandedVCF` objects
(both extending the virtual class `VCF`) of the 
`r Biocpkg("VariantAnnotation")` package.

Typically, `CollapsedVCF` objects are produced by the
`r Biocpkg("VariantAnnotation")` `readVcf` method after parsing a VCF file,
and `ExpandedVCF` objects result of the
`r Biocpkg("VariantAnnotation")` `expand` method applied to
a `CollapsedVCF` object.

Any information that users deem relevant for the analysis may be
imported from VCF files and stored in
`VCF` objects passed to `r Biocpkg("TVTB")` methods.
However, to enable the key functionalities of the package,
the object should include at least the following information:

* `fixed(x)`
    + No minimal requirement.
    + **Recommended**: fields `"REF"` and `"ALT"`
    
* `info(x)`
    + No minimal requirement.
    + **Recommended**: field `<vep>`: where `<vep>` stands for a user-defined
    INFO key where
    the Ensembl VEP predictions are stored in the `VCF` object
    
* `geno(x)`
    + `GT`: genotypes

* `colData(x)`: phenotypes

\bioccomment{
In the future, `geno(x)[["GQ"]]` may be recommended, if available.
For instance, this could enable inclusion or exclusion of individual
genotypes on the basis of passing a genotype quality cut-off
when counting genotypes in phenotype levels.
}

## List of genomic ranges {#ImportGRangesList}

In the near future, `r Biocpkg("TVTB")` functionalities are expected to
produce summary statistics and plots faceted by meta-features,
each potentially composed of multiple genomic ranges.

For instance, burden tests may be performed on a set of transcripts,
considering only variants in their respective sets of exons.
The `r Biocpkg("GenomicRanges")` `GRangesList` class is an ideal container
for this type of data,
as each `GRanges` in the `GRangesList` can represent a transcript,
and each element in the `GRanges` can represent an exon.

Although currently, none of the `r Biocpkg("TVTB")` package functions
access the `ranges` slot
of `TVTBparam` objects, users may already use it to store a list of genomic
ranges, thereby reducing the number of objects in their workspace.
For instance, the `r Biocpkg("VariantAnnotation")` `ScanVcfParam` class
accepts `r Biocpkg("GenomicRanges")` `GRanges` objects (in the `which` slot)
that describes the sequences and ranges to be queried from VCF file(s):

```{r, reduceGRangesList}
ScanVcfParam(which = GenomicRanges::reduce(unlist(ranges(tparam))))
```

## Phenotypes {#ImportPhenotypes}

Although `VCF` objects may exist without it,
phenotype information is critical to interpret and compare genetic variants
between groups of samples
(*e.g.* burden of damaging variants in different phenotype levels).

`VCF` objects accept phenotype information
(as `r Biocpkg("S4Vectors")` `DataFrame`) in the `colData` slot.
This practice has the key advantage of keeping phenotype and genetic
information synchronised through operation such as subsetting and re-ordering,
limiting [software entropy](https://en.wikipedia.org/wiki/Software_entropy).

## Example {#ImportExample}

An `ExpandedVCF` object that contains the minimal data necessary for the rest
of the vignette can be created as follows:

**Step 1:** Import phenotypes

```{r importPhenotypes}
extdata <- system.file("extdata", package = "TVTB")
phenoFile <- file.path(extdata, "integrated_samples.txt")
phenotypes <- S4Vectors::DataFrame(
    read.table(file = phenoFile, header = TRUE, row.names = 1))
```

**Step 2:** Define the VCF file to parse

```{r vcfFile}
vcfFile <- file.path(extdata, "chr15.phase3_integrated.vcf.gz")
tabixVcf <- Rsamtools::TabixFile(file = vcfFile)
```

**Step 3:** Define VCF import parameters

```{r ScanVcfParam}
svp <- VariantAnnotation::ScanVcfParam(
    fixed = c("ALT", "QUAL", "FILTER"), # all fields: could be omitted
    info = vep(tparam), # an application of the TVTBparam class
    geno = "GT", # all fields: could be omitted in this case
    samples = rownames(phenotypes),
    which = GenomicRanges::reduce(unlist(ranges(tparam))))
```

Of particular interest in the above chunk of code:

* `samples`: import only samples with phenotype information
* `info` demonstrates the utility of the `TVTBparam` class for storing
    recurrent parameters
* `which`: import only variants in the targeted list of genomic ranges
    + demonstrates another application of the `TVTBparam` class

**Step 4:** Import and pre-process variants

```{r preprocessVariants, message=FALSE}
# Import variants as a CollapsedVCF object
vcf <- VariantAnnotation::readVcf(file = tabixVcf, param = svp)
# Combine with phenotype information
SummarizedExperiment::colData(vcf) <- phenotypes
# Expand into a ExpandedVCF object (bi-allelic records)
vcf <- VariantAnnotation::expand(x = vcf, row.names = TRUE)
```

The result is an `ExpandedVCF` object that includes variants
in the desired genomic range(s) and samples:

```{r vcf, echo=FALSE}
vcf
```

# Adding allele frequencies {#Frequencies}

Although interesting figures and summary tables may be obtained
as soon as the first `ExpandedVCF` object is created
(see section [Summarising Ensembl VEP predictions](#Summarise)),
those methods may benefit from information added to additional INFO keys
after data import, either manually by the user, or through various
methods implemented in the `r Biocpkg("TVTB")` package.

## Adding overall frequencies {#FrequenciesOverall}

For instance, the method `addOverallFrequencies` uses the
reference homozoygote (*REF*), heterozygote (*HET*),
and homozygote alternate (*ALT*) genotypes defined in a `TVTBparam` object
to obtain the count of each genotype in an `ExpandedVCF` object.
Immediately thereafter, the method uses those counts to calculate
alternate allele frequency (*AAF*) and minor allele frequency (*MAF*).
Finally, the method stores the five calculated values
(*REF*, *HET*, *ALT*, *AAF*, and *MAF*)
in INFO keys defined by suffixes also declared in the `TVTBparam` object.

```{r addOverallFrequencies}
initialInfo <- colnames(info(vcf))
vcf <- addOverallFrequencies(vcf = vcf, param = tparam)
setdiff(colnames(info(vcf)), initialInfo)
```

Notably, the `addOverallFrequencies` method is synonym to the `addFrequencies`
method missing the argument `phenos`:

```{r addFrequenciesOverall}
vcf <- addFrequencies(vcf = vcf, param = tparam, force = TRUE)
```

\bioccomment{
The optional argument `force = TRUE` is used here
to overwrite INFO keys created in the previous chunk of code.
}

## Adding frequencies in phenotype level(s) {#FrequenciesPhenoLevel}

Similarly, the method `addPhenoLevelFrequencies` obtains the count of each
genotype in samples associated with given level(s) of given phenotype(s),
and stores the calculated values in INFO keys defined as 
`<pheno>_<level>_<suffix>`, with suffixes defined in the `TVTBparam` object.

```{r addPhenoLevelFrequencies}
initialInfo <- colnames(info(vcf))
vcf <- addPhenoLevelFrequencies(
    vcf = vcf, pheno = "super_pop", level = "AFR", param = tparam)
setdiff(colnames(info(vcf)), initialInfo)
```

Notably, the `addPhenoLevelFrequencies` method is synonym
to the `addFrequencies`
method called with the argument `phenos` given as a list where `names` are
phenotypes, and values are `character` vectors of levels to
process within each phenotype:

```{r addFrequenciesPhenoLevel}
initialInfo <- colnames(info(vcf))
vcf <- addFrequencies(
    vcf = vcf, phenos = list(
        super_pop = c("EUR", "AFR"),
        pop = c("GBR", "FIN", "MSL")),
    param = tparam, force = TRUE)
setdiff(colnames(info(vcf)), initialInfo)
```

# Filtering variants {#Filter}

Although `VCF` objects are straightforward to subset
using either indices and row names
(as they inherit from the `r Biocpkg("SummarizedExperiment")` 
`RangedSummarizedExperiment` class),
users may wish to identify variants that pass combinations of criteria based on
information in their `fixed` slot, `info` slot, and Ensembl VEP predictions,
a non-trivial task due to those pieces of information being stored in
different slots of the `VCF` object, and the *1:N* relationship
between variants and EnsemblVEP predictions.

## Definition of VCF filter rules {#FilterDefine}

To facilitate the definition of VCF filter rules, and their application to
`ExpandedVCF` objects, `r Biocpkg("TVTB")` extends the `r Biocpkg("S4Vectors")`
`FilterRules` class in four new classes of filter rules:

|       Class       | Motivation                                              |
| :--------------:  | :------------------------------------------------------ |
|  VcfFixedRules    | Filter rules applicable to the `fixed` slot of a        |
|                   | `VCF` object.                                           |
|                   |                                                         |
|   VcfInfoRules    | Filter rules applicable to the `info` slot of a         |
|                   | `VCF` object.                                           |
|                   |                                                         |
|   VcfVepRules     | Filter rules applicable to the Ensembl VEP predictions  |
|                   | stored in a given INFO key of a `VCF` object.           |
|                   |                                                         |
|  VcfFilterRules   | Combination of `VcfFixedRules`, `VcfInfoRules`, and     |
|                   |  `VcfVepRules` applicable to a `VCF` object.            |

Table: Motivation for each of the new classes extending `FilterRules`
to define VCF filter rules.

Instances of those classes may be initialised as follows:

**VcfFixedRules**

```{r VcfFixedRules}
fixedR <- VcfFixedRules(exprs = list(
    pass = expression(FILTER == "PASS"),
    qual = expression(QUAL > 20)
    ))
fixedR
```

**VcfInfoRules**

```{r VcfInfoRules}
infoR <- VcfInfoRules(exprs = list(
    common = expression(MAF > 0.1), # minor allele frequency
    present = expression(ALT + HET > 0) # count of non-REF homozygotes
    ),
    active = c(TRUE, FALSE))
infoR
```

`FilterRules` are initialised in an active state by default.
The above chunk of code demonstrate how the `active` argument
of their constructor may be used to initialise
specific filter rules in an inactive state.

**VcfVepRules**

```{r VcfVepRules}
vepR <- VcfVepRules(exprs = list(
    missense = expression(Consequence %in% c("missense_variant")),
    CADD = expression(CADD_PHRED > 15)
    ))
vepR
```

**VcfFilterRules**

`VcfFilterRules` combine VCF filter rules of  different types
in a single object.

```{r VcfFilterRules}
vcfRules <- VcfFilterRules(fixedR, infoR, vepR)
vcfRules
```

## Control of VCF filter rules {#FilterControl}

As the above classes of *VCF filter rules* inherit
from the `r Biocpkg("S4Vectors")` `FilterRules` class,
they also benefit from its accessors and methods.
For instance, VCF filter rules can easily be toggled
between active and inactive states:

```{r deactivateCADD}
active(vcfRules)["CADD"] <- FALSE
active(vcfRules)
```

A separate vignette described in greater detail the use of classes
that contain *VCF filter rules*.

Manipulation of *VCF filter rules* is described in more depth in a separate
vignette.

## Evaluation of VCF filter rules {#FilterEval}

Once defined, the above filter rules can be applied to `ExpandedVCF` objects,
in the same way as `FilterRules` are evaluated in a given environment
(see the `r Biocpkg("S4Vectors")` documentation):

```{r}
summary(eval(expr = infoR, envir = vcf))
summary(eval(expr = vcfRules, envir = vcf))
summary(evalSeparately(expr = vcfRules, envir = vcf))
```

\bioccomment{
Note how the inactive rule `CADD` returns `TRUE` for all variants.
}

\fixme{
Not sure why in the vignette `summary` behaves like `summary.data.frame`,
while in RStudio it processes the `FilterMatrix` differently (rightly so).
}

# Summarising Ensembl VEP predictions {#Summarise}

As soon as genetic and phenotypic information are imported
into an `ExpandedVCF` object,
or after the object was extended with additional information,
the scientific value of the data may be revealed by
a variety of summary statistics and graphical representations.
This section presents severeal ideas implemented in `r Biocpkg("TVTB")`.

It is important to highlight that `ggplot` objects
include the data used for plotting in their `data` slot.
Those data may be extracted, subsetted, and replaced to refine plots and
summary tables beyond those produced by the package methods.
In particular, the associated web-application *tSVE* takes advantage of this
point to avoid calling multiple times certain same time-consuming methods.

## Counts of discrete Ensembl VEP predictions {#SummariseDiscrete}

### Barplot {#SummariseDiscreteBarplot}

The following chunk of code displays,
for each "super-population"
(*i.e.*, each level of the `"super_pop"` phenotype),
the count of each Ensembl VEP prediction `"Consequence"`
affecting each "genomic feature" (*i.e.* , transcript),
considering for each super-population only variants:

* seen at least once among the corresponding group of samples
* with a [CADD score](http://cadd.gs.washington.edu)[^1] greater than `20`

[^1]: 
A tool for scoring the deleteriousness of genetic variants.

```{r optsTabulateSet, include=FALSE}
opts_chunk$set(
    fig.width=13, fig.height=7,
    out.extra='angle=90',
    out.width='7in', out.height='13in'
)
```

```{r tCBPplot, message=FALSE}
library(ggplot2)
filterCADD <- VcfVepRules(exprs = list(
    CADD_20 = expression(as.numeric(CADD_PHRED) > 20)
    ))
tCBPplot <- tabulateVepByPhenotype(
    vcf = vcf, phenoCol = "super_pop", vepCol = "Consequence",
    param = tparam, filter = filterCADD,
    unique = TRUE, facet = "Feature", percentage = FALSE,
    plot = TRUE) +
    theme(
        legend.text = element_text(size = rel(0.8)),
        axis.text.x = element_text(angle = 270,vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270,hjust = 0.5)
    )

tCBPplot
```

```{r optsTabulateReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

### Table (data.frame) {#SummariseDiscreteTable}

The same counts can also be summarised as a `data.frame` using
the option `plot=FALSE`:

```{r tCBPtableWide}
tCBPwide <- tabulateVepByPhenotype(
        vcf = vcf, phenoCol = "super_pop", vepCol = "Consequence",
        param = tparam,
        unique = TRUE, facet = "Feature", plot = FALSE
    )
```

of which only the subset corresponding to *missense variants* is shown here:

```{r tCBPtableWideSubset, eval=FALSE}
subset(tCBPwide, Consequence == "missense_variant")
```

```{r tCBPtableWideSubsetShow, results="asis", echo=FALSE}
knitr::kable(
    x = subset(tCBPwide, Consequence == "missense_variant"),
    row.names = FALSE,
    caption = "Table of consequence by phenotype by feature in wide format.")
```

## Distribution of continuous Ensembl VEP predictions {#SummariseContinuous}

For Ensembl VEP predictions on a continuous scale, it may be interesting to
visualise the distribution of values as a density plot.
In the following chunk of code, the density distribution of
[CADD score](http://cadd.gs.washington.edu) is visualised
for *missense variants* affecting each feature in each super-population:

```{r optsDensitySet, include=FALSE}
opts_chunk$set(
    fig.width=13, fig.height=7,
    out.extra='angle=90',
    out.width='7in', out.height='13in'
)
```

```{r dCBPplot, warning=FALSE, message=FALSE}
densityVepByPhenotype(
        vcf = vcf, phenoCol = "super_pop", vepCol = "CADD_PHRED",
        param = tparam, filter = vcfRules["missense"],
        unique = TRUE, facet = "Feature", plot = TRUE, popFreq = FALSE,
        layer = "density+dotplot") +
    theme(
        legend.key.size = unit(1.2, "lines"),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)),
        axis.text.x = element_text(angle = 270,
            vjust = 0.5),
        axis.title.y = element_text(angle = 270),
        axis.text.y = element_text(angle = 270, hjust = 0.5)
    )
```

```{r optsDensityReset, include=FALSE}
opts_chunk$set(optChunkDefault)
```

# Session info {#SessionInfo}

Here is the output of `sessionInfo()` on the system on which this document was
compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {#References}

[R]: http://r-project.org
[RStudio]: http://www.rstudio.com/
